{"version":3,"file":"promise.js","sources":["../src/js/promise.js","../src/js/hard-promise.js"],"sourcesContent":["// setTimeout(() => {\n//   console.log('setTimeout');\n// }, 0);\n\n// console.log('console.log: 1');\n\n// Promise.resolve()\n//   .then(() => {\n//     console.log('promise: 1');\n//   })\n//   .then(() => {\n//      console.log('promise: 2');\n//    });\n\n//  console.log('console.log: 2');\n\n// const getRandomDelay = () => Math.ceil(Math.random() * 2000);\n// const promise = new Promise((resolve, reject) => {\n//   const delay = getRandomDelay();\n//   // resolve({message :'Done!', delay})\n//   setTimeout(() => {\n//     console.log('timeOut');\n//     resolve({ message: 'success', delay });\n//   }, delay);\n// });\n// promise\n//   .then(console.log)\n//   .catch(error => {\n//     console.log(error);\n//   })\n//   .finally(() => {\n//     console.log('end');\n//   });\n\n/**\n * Перероби функцію на проміс таким чином, щоб проміс повертав значення\n * через 2 секунди після виклику функції\n */\n//\n// function greet() {\n//   const promise = new Promise(resolve => {\n//     setTimeout(() => {\n//       resolve('hello world');\n//     }, 2000);\n//   });\n//   return promise;\n// }\n// greet().then(console.log);\n\n\n/*\n * Є функція, яка генерує випадкові числа від 1 до 4.\n * Написати функцію, яка повертає проміс.\n * Зробіть так, щоб згенероване число було із затримкою функції setTimeout в секундах.\n * Оберніть все це в проміс, який у будь-якому разі повертає час затримки (і в resolve, і в reject).\n * Нехай проміс виконається успішно, якщо згенеровано 1 або 2 (`✅ Resolved after ${delay} sec`),\n * і з помилкою - якщо 3 або 4 (`❌ Rejected after ${delay} sec`).\n */\n\n// const getRandomNumber = () => Math.floor(Math.random() * 4) + 1\n//\n// const makePromise = () =>{\n//   return new Promise ((resolve, reject)=>{\n//     const delay = getRandomNumber()\n//     setTimeout(()=>{\n//       if(delay <=2) {\n//         resolve(`✅ Resolved after ${delay} sec`)\n//       }\n//       reject(`❌ Rejected after ${delay} sec`)\n//     }, delay*1000)\n//   })\n// }\n//\n// makePromise().then(console.log).catch(console.log)\n\n\n\nimport iziToast from 'izitoast';\n\nconst form = document.querySelector('.form')\nconst getRandomNumber = () => Math.floor(Math.random() * 4) + 1\n\nconst createPromise = (position, delay) =>{\n  return new Promise ((resolve, reject)=>{\n     const should = getRandomNumber()>=2\n    setTimeout(()=>{\n      if(should){\n        resolve({ position, delay })\n      }\n      reject({ position, delay })\n    }, delay)\n  })\n}\n\nconst handleSubmit = (event)=>{\n  event.preventDefault()\n  const { delay, step, amount } = event.target.elements\n  const delayValue = Number(delay.value)\n  const stepValue = Number(step.value)\n  const amountValue = Number(amount.value)\n\n  for(let i = 0; i<amountValue; i++){\n    createPromise(i+1, delayValue+stepValue*i).then(onSuccess).catch(onError)\n\n  }\n  event.target.reset()\n}\nform.addEventListener('submit', handleSubmit)\n\nfunction onSuccess({ position, delay }) {\n  iziToast.success({message: `✅ Fulfilled promise ${position} in ${delay}ms`\n});\n}\n\nfunction onError({ position, delay }) {\n  iziToast.error({message: `❌ Rejected promise ${position} in ${delay}ms`});\n}","/*\n * Methods:\n * Promise.race(array) - повертає перший успішно виконаний або відхилений проміс, зі значенням чи причиною відхилення цього промісу.\n *\n * Promise.all(array) - повертає проміс, який виконається тоді, коли будуть успішно виконані всі проміси, або відхилено будь-який з них.\n *\n * Promise.allSettled(array) - повертає проміс, який виконується коли всі отримані проміси завершені (успішно виконані або відхилені),\n * міститиме масив результатів отриманих промісів (status і value для успішних, status та reason для неуспішних)\n *\n * Promise.any(array) - як тільки один із промісів виконається успішно, метод поверне значення виконаного промісу.\n *  Якщо жоден із промісів не завершиться успішно, тоді повернутий Promise буде відхилено\n */\n/*\n\n * Зробіть 3 проміси - по одному для кожного фреймворку з масиву.\n * У кожному розташована функція setTimeout із випадковою затримкою від 0 до 2 секунд.\n * Зробити так, щоб проміси і резолвилися, і реджектилися випадково.\n * Нехай кожен проміс своїм результатом повертає цю затримку та ім'я фреймворку, а при помилці ще й текст помилки 'Promise error'.\n */\n/*\n * За допомогою Promise.race дочекайтеся завантаження першого промісу, що спрацював, і виведіть результат його роботи \nна екран: `✅ ${Framework_name} won with ${delay} ms`\n * або результат помилки: `❌ ${error}! ${name} rejected in ${delay} ms`\n */\n\n// const onSuccess = ({ framework, delay }) => {\n//   console.log(`✅ ${framework} won with ${delay} ms`);\n// };\n\n// const onError = ({ framework, delay, error }) => {\n//   console.log(`❌ ${error}! ${framework} rejected in ${delay} ms`);\n// };\n\n// const frameworks = ['React', 'Vue', 'Angular'];\n\n// const getRandomDelay = () => Math.ceil(Math.random() * 2000);\n\n// const promises = frameworks.map(framework => {\n//   return new Promise((resolve, reject) => {\n//     const delay = getRandomDelay();\n//     setTimeout(() => {\n//       if (delay < 500) {\n//         resolve({ framework, delay });\n//       }\n//       reject({ error: 'Promise error', framework, delay });\n//     }, delay);\n//   });\n// });\n\n// Promise.race(promises).then(onSuccess).catch(OnError);\n\n/*\n * За допомогою Promise.all отримайте масив результатів\n * Виведіть на екран інформацію, з якою затримкою виконався проміс для кожного фреймфорка: `✅ ${Framework_name} fulfilled in ${delay} ms`\n * Або з якою затримкою зареджектився один із них: `❌ ${error}! ${Framework_name} rejected in ${delay} ms`\n */\n// Promise.all(promises)\n//   .then(resolve => {\n//     resolve.forEach(onSuccess);\n//   })\n//   .catch(OnError);\n\n/*\n * За допомогою Promise.allSettled отримайте масив результатів.\n * Виведіть на екран інформацію, з яким результатом виконався проміс для кожного фреймфорка:\n * `✅ ${Framework_name} fulfilled in ${delay} ms`\n * `❌ ${error}! ${Framework_name} rejected in ${delay} ms`\n *\n * Приклад відповіді:\n * {status: \"fulfilled\", value: 99},\n * {status: \"rejected\", reason: Error: an error}\n */\n// Promise.allSettled(promises).then(resolve => {\n//   resolve.forEach(response => {\n//     if (response.status === 'rejected') {\n//       onError(response.reason);\n//     } else {\n//       onSuccess(response.value);\n//     }\n//   });\n// });\n\n/*\n * За допомогою Promise.any дочекайтеся завантаження першого успішного промісу та виведіть результат його роботи на екран: `✅ ${Framework_name} won with ${delay} ms` або результат помилки кожного промісу в catch: `❌ ${error}! ${name} rejected in ${delay} ms`\n * Приклад об'єкта помилки в catch:\n * {\n * errors: (3) [{…}, {…}, {…}]\n * message: \"All promises were rejected\"\n * stack: \"AggregateError: All promises were rejected\"\n * }\n */\n\n// Promise.any(promises)\n//   .then(onSuccess)\n//   .catch(reject => {\n//     reject.errors.toSorted((a, b) => b.delay - a.delay).forEach(onError);\n//   });\n\n/**\n * Перероби код так, щоб усі дані збиралися\n * одноразово і приходили у вигляді масиву\n */\n\n// const getData = () =>\n//   new Promise(res => {\n//     setTimeout(() => {\n//       const data = 1;\n//       //console.log(data);\n//       res(data);\n//     }, 1000);\n//   });\n\n// const getNewData = () =>\n//   new Promise(res => {\n//     setTimeout(() => {\n//       const data = 2;\n//       //console.log(data);\n//       res(data);\n//     }, 1000);\n//   });\n\n// const getAnotherData = () =>\n//   new Promise(res => {\n//     setTimeout(() => {\n//       const data = 3;\n//       //console.log(data);\n//       res(data);\n//     }, 1000);\n//   });\n\n// const getLastData = () =>\n//   new Promise(res => {\n//     setTimeout(() => {\n//       const data = 4;\n//       // console.log(data);\n//       res(data);\n//     }, 1000);\n//   });\n\n// const array = [];\n// getData()\n//   .then(response => {\n//     array.push(response);\n//     return getNewData();\n//   })\n//   .then(response => {\n//     array.push(response);\n//     return getAnotherData();\n//   })\n//   .then(response => {\n//     array.push(response);\n//     return getLastData();\n//   })\n//   .then(response => {\n//     array.push(response);\n//     console.log(array);\n//   });\n\n// Promise.all([getData(), getNewData(), getAnotherData(), getLastData()]).then(\n//   result => {\n//     console.log(result);\n//   }\n// );\n\n/**\n * Функція countWithDelay приймає приймає 3 аргументи:\n * 1) кількість секунд перед тим як спрацює ф-ція logCount\n * 2) скільки разів має відпрацювати logCount\n * 3) затримка між викликами ф-ції\n *\n * logCount повинна логувати кількість викликів\n */\nconst createPromise = (delay, callBack) => {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  }).then(callBack);\n};\nconst countWithDelay = (delay, times, interval) => {\n  let amount = 0;\n  const counterAmount = counterInterval => {\n    amount += 1;\n    console.log(`delay: ${counterInterval || delay}`, 'count', amount);\n    if (amount === times) return;\n    setTimeout(() => {\n      counterAmount(interval);\n    }, interval);\n  };\n  createPromise(delay, counterAmount);\n};\ncountWithDelay(1000, 3, 2000);\n"],"names":["form","getRandomNumber","createPromise","position","delay","resolve","reject","should","handleSubmit","event","step","amount","delayValue","stepValue","amountValue","i","onSuccess","onError","iziToast","callBack","countWithDelay","times","interval","counterAmount","counterInterval"],"mappings":"wIA+EA,MAAMA,EAAO,SAAS,cAAc,OAAO,EACrCC,EAAkB,IAAM,KAAK,MAAM,KAAK,OAAM,EAAK,CAAC,EAAI,EAExDC,EAAgB,CAACC,EAAUC,IACxB,IAAI,QAAS,CAACC,EAASC,IAAS,CACpC,MAAMC,EAASN,KAAmB,EACnC,WAAW,IAAI,CACVM,GACDF,EAAQ,CAAE,SAAAF,EAAU,MAAAC,CAAO,CAAA,EAE7BE,EAAO,CAAE,SAAAH,EAAU,MAAAC,CAAO,CAAA,CAChC,EAAOA,CAAK,CACT,CAAA,EAGGI,EAAgBC,GAAQ,CAC5BA,EAAM,eAAc,EACpB,KAAM,CAAE,MAAAL,EAAO,KAAAM,EAAM,OAAAC,CAAM,EAAKF,EAAM,OAAO,SACvCG,EAAa,OAAOR,EAAM,KAAK,EAC/BS,EAAY,OAAOH,EAAK,KAAK,EAC7BI,EAAc,OAAOH,EAAO,KAAK,EAEvC,QAAQI,EAAI,EAAGA,EAAED,EAAaC,IAC5Bb,EAAca,EAAE,EAAGH,EAAWC,EAAUE,CAAC,EAAE,KAAKC,CAAS,EAAE,MAAMC,CAAO,EAG1ER,EAAM,OAAO,MAAK,CACpB,EACAT,EAAK,iBAAiB,SAAUQ,CAAY,EAE5C,SAASQ,EAAU,CAAE,SAAAb,EAAU,MAAAC,GAAS,CACtCc,EAAS,QAAQ,CAAC,QAAS,uBAAuBf,CAAQ,OAAOC,CAAK,IACxE,CAAC,CACD,CAEA,SAASa,EAAQ,CAAE,SAAAd,EAAU,MAAAC,GAAS,CACpCc,EAAS,MAAM,CAAC,QAAS,sBAAsBf,CAAQ,OAAOC,CAAK,IAAI,CAAC,CAC1E,CCwDA,MAAMF,EAAgB,CAACE,EAAOe,IACrB,IAAI,QAAQd,GAAW,CAC5B,WAAWA,EAASD,CAAK,CAC7B,CAAG,EAAE,KAAKe,CAAQ,EAEZC,EAAiB,CAAChB,EAAOiB,EAAOC,IAAa,CACjD,IAAIX,EAAS,EACb,MAAMY,EAAgBC,GAAmB,CACvCb,GAAU,EACV,QAAQ,IAAI,UAAUa,GAAmBpB,CAAK,GAAI,QAASO,CAAM,EAC7DA,IAAWU,GACf,WAAW,IAAM,CACfE,EAAcD,CAAQ,CACvB,EAAEA,CAAQ,CACZ,EACDpB,EAAcE,EAAOmB,CAAa,CACpC,EACAH,EAAe,IAAM,EAAG,GAAI"}